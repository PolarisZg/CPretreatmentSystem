# CPretreatmentSystem_C语言的预处理程序

## 项目目的
只是为了完成本年度的编译原理课程设计的课设 `(*ﾟ∇ﾟ)`

## 题目要求
&ensp;&ensp;设计一个C语言的预处理程序。将给出C语言的所有宏常量进行计算，并生成另外一个文件，将宏常量的展开和计算结果全部显示出来。<br>
&ensp;&ensp;将定义的宏在源程序中全部替换

## 程序处理过程 1.1

### 各个类的解释

#### `class data`

这个类用来去存放程序运行过程中所需要的数据:<br>

* `data_SaveWord` C语言程序的保留字，宏展开的时候需要将其略过<br>
* `data_defineData` C语言程序代码中的宏名，在遍历程序使根据宏名进行宏展开<br>
* `data_operator` 这个类暂时很杂，现在里面存放了在遍历程序时需要略过的算术运算符以及空格回车等等符号, 当前这个类就是用来对输入的文件进行预处理，从里面分割单词和运算符<br>
* `data_code` 从文件中读取代码嘛，就要在程序中保存下来，这个类使用`ArrayList`保存C语言代码，一行就是一个`ArrayList`，然后再将这些行串起来

#### `FileProcessor`

这个类用来处理C语言代码文件，读入C语言代码，然后将其转换为以`ArrayList`的形式存放的代码链

#### `code_processor`

这个类用来处理上面以 `ArrayList` 保存下来的代码链，先分离所有宏声明的变量，并把这些变量放置在字典 `data_defineData` 中<br>

> 这里使用了一个对于代码的限制，`#define`定义的宏变量需要是这样的形式，即 `#define + 空格* + 变量名 + 空格* + 变量内容`

然后再去分离代码中的变量和变量类型 <small>这里我还没写</small>

#### `etc`

一个杂项类，里面放一些不知道该放哪的代码，现在里面的代码有:<br>
* `typeString` 这个方法用来判断宏类型定义的变量的类型，由于题目设定的原因，不仅要进行宏展开还要进行对于宏内部数据的运算(什么垃圾题目，宏就是用来全部替换展开的，还要对宏进行化简)，运算就要获得宏内容的数据类型，所以就写一个方法去判断到底是整型还是浮点型还是字符串

### 完了
词法分析 语法分析 语义分析 转为后缀式 求值 完事。
本来还想用动态编译来偷个懒~~~

## 以下的是交作业时写的

# 课程报告

## 4 详细设计

### 4.1 数据分析与定义

#### 4.1.1 代码数据
&ensp;&ensp;&ensp;&ensp;在程序中，代码数据由链表 `ArrayList<String>` 记录。<br>
&ensp;&ensp;&ensp;&ensp;代码文件载入到程序中之后，程序开辟代码数据缓冲区记录代码数据，为方便之后对代码进行分析和替换，因此代码数据缓冲区使用 `ArrayList` 结构对代码进行记录。 `ArrayList` 便于对代码数据进行修改替换和增加删除。<br>

#### 4.1.2 宏数据
&ensp;&ensp;&ensp;&ensp;在程序中，使用一个自定义类data_object对每个宏数据进行存储。<br>
&ensp;&ensp;&ensp;&ensp;该自定义类包括的属性有:<br>
* 对宏内容进行区分的字符串 `String object_type` 在本程序中，该字符串仅能有四种取值，分别为：`"int"` `"double"` `"string"` `"operate"`分别代表该宏内容被解析后所表达的格式为整型数，浮点型数，仅是字符串和表达式。
* 整型数 `int object_valueInt`, 当上方的 `object_type` 取值为 `"int"` 时此值才有意义。
* 浮点型数 `double object_double`, 当上方的 `object_type` 取值为 `"double"` 时此值才有意义。
* 链表 `ArrayList<String> object_valueStr`, 将宏内容按照空格或其他分隔符解析为链表结构存储在此属性中。
* 布尔值 `boolean object_isOperate`, 记录此宏内容是否为表达式，只有当上方的 `object_type` 取值为 `"int"` `"double"` `"operate"` 时此值为 `true` 否则为 `false` 。
* 链表 `ArrayList<String> operate` 将宏内容为表达式的解析为逆波兰式，存储在此链表中，只有当上方的 `object_isOperate` 为真时才有意义。
  &ensp;&ensp;&ensp;&ensp;该自定义类包含的主要方法有:
* `void mustDo(ArrayList<String> value)` 此方法为合并两个自定义类的字符串内容的方法，由于Java的内存分配问题导致在合并两个链表时会出现共用同一内存空间，进而导致修改其中一个造成另一个也被修改，而这对于顺序依次处理宏内容来说是致命的，因此自定义一个合并链表的方法，当将子链表添加到母链表结尾时，重新为母链表申请需要扩充的内存空间，然后读取子链表中的每一项，将其内容复制到母链表之中。

#### 4.1.3 运算符数据
&ensp;&ensp;&ensp;&ensp;在处理表达式时，既需要清楚的识别表达式中的运算符，也需要判断运算符的意义以及不同运算符的优先级顺序。因此定义一个运算符字典类 `dataDictionary`用来查询运算符的标识字以及运算符的优先级顺序。
&ensp;&ensp;&ensp;&ensp;因为本题目的运算符多元，因此对于运算符是按照字符串处理，而由于对字符串的处理繁琐，因此对每一个运算符用整型数去标识，每个运算符与整型数之间的对应关系由字典 `iniBinaryOperatorMap` `unaryPreOperatorMap` `unaryAftOperatorMap` 给出。
&ensp;&ensp;&ensp;&ensp;运算符的优先级顺序由二维数组 `priorityTab` 给出，使用该表时，首先使用字典查询出需要比较的两个运算符的标识字，然后二维数组相应位置的数字。

### 4.2 主要方法的实现
#### 4.2.1 数字判断方法
该方法用来解析一个字符串是十六进制整型数，十进制整型数，浮点数或仅是一字符串。该方法利用 `try-catch`嵌套使用 `Integer.parseInt()`方法, `Float.parseFloat()`, 方法，以抛出异常的形式返回数据，来判断一个字符串的解析结果。

#### 4.2.2 表达式判断方法

该方法用来判断一个以链表形式表达的宏内容是否为表达式。本程序中对于表达式的定义如下:<br>
若 S 为表达式，则需要递归的满足以下的内容中的一条。

```
S -> Number
S -> S
S -> S BinaryOperator S
S -> (S)
S -> unaryPreOperator S
S -> S unaryAftOperator
```

此方法使用递归的形式，返回布尔值，来判断一个字符串是否为表达式。

#### 4.2.3 表达式转逆波兰式方法

此方法中使用了一个符号栈去存放已从表达式链表中读出的符号，具体的实现过程如下:<br>
<1> 建立符号栈，并初始化<br>
<2> 按顺序读取传入的arrayList，读到数字则添加到结果链表中<br>
<3> 若读取到操作符号，则与栈顶的操作符号相比较，优先级高则入栈<br>
<4> 若优先级低或相等，则从栈顶依次弹出符号并添加到结果链表中，直到栈顶优先级低于等待的符号，将符号入栈<br>
<5> 括号处理：遇到左括号则直接入栈，栈顶的左括号优先级低于所有操作符，遇到右括号则弹出栈内符号直到弹出一个左括号为止<br>
<6> 读取完arrayList，将栈中符号依次出栈并添加到结果链表<br>

#### 逆波兰式求值方法

此方法按顺序读取逆波兰式中的各项，当读取到算数运算符时向前索取需要的数字，然后进行计算，并用计算结果取代向前索取的数字以及算数运算符。